package com.google.appinventor.components.runtime.arview.renderer;
import com.google.appinventor.components.annotations.UsesAssets;
import android.media.Image;
import android.opengl.GLES30;
import com.google.appinventor.components.runtime.*;
import com.google.ar.core.Coordinates2d;
import com.google.ar.core.Frame;

import java.util.HashMap;
import android.util.Log;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.Collection;

/**
 * This class renders a composite quad.
 */
@UsesAssets(fileNames = "background_show_camera.frag, background_show_camera.vert," +
        "plane.frag, plane.vert")
public class QuadRenderer {

    // Shader names.
    private static final String VERTEX_SHADER_NAME = "plane.vert";
    private static final String FRAGMENT_SHADER_NAME = "plane.frag";

    private static final String LOG_TAG = QuadRenderer.class.getSimpleName();

    private static final int BYTES_PER_FLOAT = Float.SIZE / 8;
    private static final int BYTES_PER_INT = Integer.SIZE / 8;
    private static final int COORDS_PER_VERTEX = 3; // x, z, alpha

    private static final int VERTS_PER_BOUNDARY_VERT = 2;
    private static final int INDICES_PER_BOUNDARY_VERT = 3;
    private static final int INITIAL_BUFFER_BOUNDARY_VERTS = 64;

    private static final int INITIAL_VERTEX_BUFFER_SIZE_BYTES =
            BYTES_PER_FLOAT * COORDS_PER_VERTEX * VERTS_PER_BOUNDARY_VERT * INITIAL_BUFFER_BOUNDARY_VERTS;

    private static final int INITIAL_INDEX_BUFFER_SIZE_BYTES =
            BYTES_PER_INT
                    * INDICES_PER_BOUNDARY_VERT
                    * INDICES_PER_BOUNDARY_VERT
                    * INITIAL_BUFFER_BOUNDARY_VERTS;

    private static final float FADE_RADIUS_M = 0.25f;
    private static final float DOTS_PER_METER = 10.0f;
    private static final float EQUILATERAL_TRIANGLE_SCALE = (float) (1 / Math.sqrt(3));

    private final Mesh mesh;
    private final IndexBuffer indexBufferObject;
    private final VertexBuffer vertexBufferObject;
    private Shader quadShader;
    private final Texture quadTexture;

    /**
     * Allocates and initializes OpenGL resources needed by the background renderer. Must be called
     * during a {@link ARViewRender} callback, typically in {@link
     */
    public QuadRenderer(ARViewRender render, int textureId, int width, int height) throws IOException{
        quadTexture = Texture.createFromId(render, textureId, width, height);
        Log.d(LOG_TAG, "has quadTexture? " + quadTexture);
        quadShader =
                Shader.createFromAssets(render, VERTEX_SHADER_NAME, FRAGMENT_SHADER_NAME, /*defines=*/ null)
                        .setTexture("u_Texture", quadTexture)
                        .setBlend(
                                Shader.BlendFactor.DST_ALPHA, // RGB (src)
                                Shader.BlendFactor.ONE, // RGB (dest)
                                Shader.BlendFactor.ZERO, // ALPHA (src)
                                Shader.BlendFactor.ONE_MINUS_SRC_ALPHA) // ALPHA (dest)
                        .setDepthWrite(false);
        Log.d(LOG_TAG, "has quadShader? " + quadShader);

        indexBufferObject = new IndexBuffer(render, /*entries=*/ null);
        vertexBufferObject = new VertexBuffer(render, COORDS_PER_VERTEX, /*entries=*/ null);
        VertexBuffer[] vertexBuffers = {vertexBufferObject};
        mesh = new Mesh(render, Mesh.PrimitiveMode.TRIANGLE_STRIP, indexBufferObject, vertexBuffers);


    }


    /** not sure if needed Updates the quad  matrix and extents. */
    private void updateQuadParameters(
            float[] quadMatrix, float extentX, float extentZ, FloatBuffer boundary) {

    }



    private void drawTexturedQuad() {
        if (quadShader == null) return;

        // we have shader and mesh and textureId...
        // update view and projection probably
    }


    public void draw(ARViewRender render, ARFrameBuffer framebuffer,
                     float[] viewMatrix,
                     float[] cameraProjection) {

        //drawTexturedQuad(render, quadCompositeTextureId);
        //updateQuadParameters(viewMatrix, projectionMatrix);
        render.draw(mesh, quadShader, framebuffer);

        // Set the texture for this render pass

    }

    /**
     * Return the texture generated by this object.
     */
    public Texture getQuadTexture() {
        return quadTexture;
    }

}

